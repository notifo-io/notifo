/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class UserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Get the current user.
     * @return User returned.
     */
    getUser(): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<ProfileDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProfileDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProfileDto>(<any>null);
    }

    /**
     * Update the user.
     * @param request The upsert request.
     * @return Users upserted.
     */
    postUser(request: UpdateProfileDto): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/me";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostUser(_response);
        });
    }

    protected processPostUser(response: Response): Promise<ProfileDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProfileDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProfileDto>(<any>null);
    }

    /**
     * Gets a user subscription.
     * @param topic The topic path.
     * @return Subscription exists.
     */
    getMySubscription(topic: string): Promise<SubscriptionDto> {
        let url_ = this.baseUrl + "/api/me/subscriptions/{topic}";
        if (topic === undefined || topic === null)
            throw new Error("The parameter 'topic' must be defined.");
        url_ = url_.replace("{topic}", encodeURIComponent("" + topic));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMySubscription(_response);
        });
    }

    protected processGetMySubscription(response: Response): Promise<SubscriptionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SubscriptionDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Subscription does not exist.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubscriptionDto>(<any>null);
    }

    /**
     * Deletes a user subscription.
     * @param topic The topic path.
     * @return Topic deleted.
     */
    deleteMySubscription(topic: string): Promise<void> {
        let url_ = this.baseUrl + "/api/me/subscriptions/{topic}";
        if (topic === undefined || topic === null)
            throw new Error("The parameter 'topic' must be defined.");
        url_ = url_.replace("{topic}", encodeURIComponent("" + topic));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMySubscription(_response);
        });
    }

    protected processDeleteMySubscription(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Creates a user subscription.
     * @param request The subscription settings.
     * @return Topic created.
     */
    postMySubscription(request: SubscriptionDto): Promise<void> {
        let url_ = this.baseUrl + "/api/me/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostMySubscription(_response);
        });
    }

    protected processPostMySubscription(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Query users.
     * @param appId The app where the users belongs to.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return Users returned.
     */
    getUsers(appId: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/users?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: Response): Promise<ListResponseDtoOfUserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfUserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfUserDto>(<any>null);
    }

    /**
     * Upsert users.
     * @param appId The app where the users belong to.
     * @param request The upsert request.
     * @return Users upserted.
     */
    postUsers(appId: string, request: UpsertUsersDto): Promise<UserDto[]> {
        let url_ = this.baseUrl + "/api/apps/{appId}/users";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostUsers(_response);
        });
    }

    protected processPostUsers(response: Response): Promise<UserDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto[]>(<any>null);
    }

    /**
     * Get a user.
     * @param appId The app where the user belongs to.
     * @param id The user ID.
     * @return User returned.
     */
    getUser(appId: string, id: string): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/users/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("User or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(<any>null);
    }

    /**
     * Delete a user.
     * @param appId The app where the users belongs to.
     * @param id The user id to delete.
     * @return User deleted.
     */
    deleteUser(appId: string, id: string): Promise<ListResponseDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/users/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<ListResponseDtoOfUserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfUserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfUserDto>(<any>null);
    }

    /**
     * Query user subscriptions.
     * @param appId The app where the user belongs to.
     * @param id The user ID.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return User subscriptions returned.
     */
    getSubscriptions(appId: string, id: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfSubscriptionDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/users/{id}/subscriptions?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSubscriptions(_response);
        });
    }

    protected processGetSubscriptions(response: Response): Promise<ListResponseDtoOfSubscriptionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfSubscriptionDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("User or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfSubscriptionDto>(<any>null);
    }

    /**
     * Upsert a user subscriptions.
     * @param appId The app where the user belongs to.
     * @param id The user ID.
     * @param request The subscription object.
     * @return User subscribed.
     */
    postSubscription(appId: string, id: string, request: SubscriptionDto): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/users/{id}/subscriptions";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostSubscription(_response);
        });
    }

    protected processPostSubscription(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("User or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Remove a user subscriptions.
     * @param appId The app where the user belongs to.
     * @param id The user ID.
     * @param prefix The topic prefix.
     * @return User subscribed.
     */
    deleteSubscription(appId: string, id: string, prefix: string): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/users/{id}/subscriptions/{prefix}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prefix === undefined || prefix === null)
            throw new Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSubscription(_response);
        });
    }

    protected processDeleteSubscription(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("User or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Add an allowed topic.
     * @param appId The app where the users belong to.
     * @param id The user ID.
     * @param request The upsert request.
     * @return User updated.
     */
    postAllowedTopic(appId: string, id: string, request: AddAllowedTopicDto): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/users/{id}/allowed-topics";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostAllowedTopic(_response);
        });
    }

    protected processPostAllowedTopic(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("User or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Remove an allowed topic.
     * @param appId The app where the users belong to.
     * @param id The user ID.
     * @param prefix The topic prefix.
     * @return User updated.
     */
    deleteAllowedTopic(appId: string, id: string, prefix: string): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/users/{id}/allowed-topics/{prefix}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prefix === undefined || prefix === null)
            throw new Error("The parameter 'prefix' must be defined.");
        url_ = url_.replace("{prefix}", encodeURIComponent("" + prefix));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAllowedTopic(_response);
        });
    }

    protected processDeleteAllowedTopic(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("User or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class TopicsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Query topics.
     * @param appId The app where the topics belongs to.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return Topics returned.
     */
    getTopics(appId: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfTopicDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/topics?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTopics(_response);
        });
    }

    protected processGetTopics(response: Response): Promise<ListResponseDtoOfTopicDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfTopicDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfTopicDto>(<any>null);
    }
}

export class TemplatesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Query templates.
     * @param appId The app where the templates belongs to.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return Templates returned.
     */
    getTemplates(appId: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/templates?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplates(_response);
        });
    }

    protected processGetTemplates(response: Response): Promise<ListResponseDtoOfTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfTemplateDto>(<any>null);
    }

    /**
     * Upsert templates.
     * @param appId The app where the templates belong to.
     * @param request The upsert request.
     * @return Templates upserted.
     */
    postTemplates(appId: string, request: UpsertTemplatesDto): Promise<TemplateDto[]> {
        let url_ = this.baseUrl + "/api/apps/{appId}/templates";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostTemplates(_response);
        });
    }

    protected processPostTemplates(response: Response): Promise<TemplateDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TemplateDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemplateDto[]>(<any>null);
    }

    /**
     * Delete a template.
     * @param appId The app where the templates belong to.
     * @param code The template code to delete.
     * @return Template deleted.
     */
    deleteTemplate(appId: string, code: string): Promise<ListResponseDtoOfTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/templates/{code}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTemplate(_response);
        });
    }

    protected processDeleteTemplate(response: Response): Promise<ListResponseDtoOfTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfTemplateDto>(<any>null);
    }
}

export class NotificationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Query user notifications.
     * @param appId The app where the user belongs to.
     * @param id The user id.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return User notifications returned.
     */
    getNotifications(appId: string, id: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfUserNotificationDetailsDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/users/{id}/notifications?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotifications(_response);
        });
    }

    protected processGetNotifications(response: Response): Promise<ListResponseDtoOfUserNotificationDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfUserNotificationDetailsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("User or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfUserNotificationDetailsDto>(<any>null);
    }

    /**
     * Query user notifications of the current user.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return Notifications returned.
     */
    getMyNotifications(query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfUserNotificationDto> {
        let url_ = this.baseUrl + "/api/me/notifications?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyNotifications(_response);
        });
    }

    protected processGetMyNotifications(response: Response): Promise<ListResponseDtoOfUserNotificationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfUserNotificationDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfUserNotificationDto>(<any>null);
    }

    /**
     * Query archhived user notifications of the current user.
     * @return Notifications returned.
     */
    getMyArchive(): Promise<ListResponseDtoOfUserNotificationDto> {
        let url_ = this.baseUrl + "/api/me/notifications/archive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyArchive(_response);
        });
    }

    protected processGetMyArchive(response: Response): Promise<ListResponseDtoOfUserNotificationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfUserNotificationDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfUserNotificationDto>(<any>null);
    }

    /**
     * Confirms the user notifications for the current user.
     * @param request The request object.
     * @return Notifications updated.
     */
    confirmMe(request: TrackNotificationDto): Promise<void> {
        let url_ = this.baseUrl + "/api/me/notifications/handled";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmMe(_response);
        });
    }

    protected processConfirmMe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class MobilePushClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Returns the mobile push tokens.
     * @return Mobile push tokens returned.
     */
    getMyToken(): Promise<ListResponseDtoOfMobilePushTokenDto> {
        let url_ = this.baseUrl + "/api/me/mobilepush";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyToken(_response);
        });
    }

    protected processGetMyToken(response: Response): Promise<ListResponseDtoOfMobilePushTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfMobilePushTokenDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfMobilePushTokenDto>(<any>null);
    }

    /**
     * Register a mobile push token for the current user.
     * @param request The request object.
     * @return Mobile push token registered.
     */
    postMyToken(request: RegisterMobileTokenDto): Promise<void> {
        let url_ = this.baseUrl + "/api/me/mobilepush";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostMyToken(_response);
        });
    }

    protected processPostMyToken(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Deletes a mobile push token for the current user.
     * @param token The token to remove.
     * @return Mobile push token removed.
     */
    deleteMyToken(token: string): Promise<void> {
        let url_ = this.baseUrl + "/api/me/mobilepush/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMyToken(_response);
        });
    }

    protected processDeleteMyToken(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class MediaClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Query media items.
     * @param appId The app where the media belongs to.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return Media returned.
     */
    getMedias(appId: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfMediaDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/media?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMedias(_response);
        });
    }

    protected processGetMedias(response: Response): Promise<ListResponseDtoOfMediaDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfMediaDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfMediaDto>(<any>null);
    }

    /**
     * Upload a media object.
     * @param appId The app id where the media belongs to.
     * @param file (optional) 
     * @return Media uploaded.
     */
    upload(appId: string, file?: File | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/media";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Download a media object.
     * @param appId The app id where the media belongs to.
     * @param fileName The name of the media to download.
     * @param cache (optional) The cache duration.
     * @param download (optional) Set it to 1 to create a download response.
     * @param width (optional) The target width when an image.
     * @param height (optional) The target height when an image.
     * @param quality (optional) The target quality when an image.
     * @param preset (optional) A preset dimension.
     * @param mode (optional) The resize mode.
     * @param focusX (optional) The x position of the focues point.
     * @param focusY (optional) The y position of the focues point.
     * @param force (optional) True to resize it and clear the cache.
     * @return Media returned.
     */
    download(appId: string, fileName: string, cache?: number | undefined, download?: number | undefined, width?: number | null | undefined, height?: number | null | undefined, quality?: number | null | undefined, preset?: string | null | undefined, mode?: ResizeMode | null | undefined, focusX?: number | null | undefined, focusY?: number | null | undefined, force?: boolean | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/apps/{appId}/media/{fileName}?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        if (download === null)
            throw new Error("The parameter 'download' cannot be null.");
        else if (download !== undefined)
            url_ += "download=" + encodeURIComponent("" + download) + "&";
        if (width !== undefined && width !== null)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height !== undefined && height !== null)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        if (quality !== undefined && quality !== null)
            url_ += "quality=" + encodeURIComponent("" + quality) + "&";
        if (preset !== undefined && preset !== null)
            url_ += "preset=" + encodeURIComponent("" + preset) + "&";
        if (mode !== undefined && mode !== null)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (focusX !== undefined && focusX !== null)
            url_ += "focusX=" + encodeURIComponent("" + focusX) + "&";
        if (focusY !== undefined && focusY !== null)
            url_ += "focusY=" + encodeURIComponent("" + focusY) + "&";
        if (force === null)
            throw new Error("The parameter 'force' cannot be null.");
        else if (force !== undefined)
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Media or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Delete a media.
     * @param appId The app id where the media belongs to.
     * @param fileName The file name of the media.
     * @return Media deleted.
     */
    delete(appId: string, fileName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/media/{fileName}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Download a media object.
     * @param appId The app id where the media belongs to.
     * @param fileName The name of the media to download.
     * @param cache (optional) The cache duration.
     * @param download (optional) Set it to 1 to create a download response.
     * @param width (optional) The target width when an image.
     * @param height (optional) The target height when an image.
     * @param quality (optional) The target quality when an image.
     * @param preset (optional) A preset dimension.
     * @param mode (optional) The resize mode.
     * @param focusX (optional) The x position of the focues point.
     * @param focusY (optional) The y position of the focues point.
     * @param force (optional) True to resize it and clear the cache.
     * @return Media returned.
     */
    download2(appId: string, fileName: string, cache?: number | undefined, download?: number | undefined, width?: number | null | undefined, height?: number | null | undefined, quality?: number | null | undefined, preset?: string | null | undefined, mode?: ResizeMode | null | undefined, focusX?: number | null | undefined, focusY?: number | null | undefined, force?: boolean | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/assets/{appId}/{fileName}?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        if (download === null)
            throw new Error("The parameter 'download' cannot be null.");
        else if (download !== undefined)
            url_ += "download=" + encodeURIComponent("" + download) + "&";
        if (width !== undefined && width !== null)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height !== undefined && height !== null)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        if (quality !== undefined && quality !== null)
            url_ += "quality=" + encodeURIComponent("" + quality) + "&";
        if (preset !== undefined && preset !== null)
            url_ += "preset=" + encodeURIComponent("" + preset) + "&";
        if (mode !== undefined && mode !== null)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (focusX !== undefined && focusX !== null)
            url_ += "focusX=" + encodeURIComponent("" + focusX) + "&";
        if (focusY !== undefined && focusY !== null)
            url_ += "focusY=" + encodeURIComponent("" + focusY) + "&";
        if (force === null)
            throw new Error("The parameter 'force' cannot be null.");
        else if (force !== undefined)
            url_ += "force=" + encodeURIComponent("" + force) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownload2(_response);
        });
    }

    protected processDownload2(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Media or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class LogsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Query log entries.
     * @param appId The app where the log entries belongs to.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return Log entries returned.
     */
    getLogs(appId: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfLogEntryDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/logs?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLogs(_response);
        });
    }

    protected processGetLogs(response: Response): Promise<ListResponseDtoOfLogEntryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfLogEntryDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfLogEntryDto>(<any>null);
    }
}

export class EventsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Query events.
     * @param appId The app where the events belongs to.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return Events returned.
     */
    getEvents(appId: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfEventDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/events?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEvents(_response);
        });
    }

    protected processGetEvents(response: Response): Promise<ListResponseDtoOfEventDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfEventDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfEventDto>(<any>null);
    }

    /**
     * Publish events.
     * @param appId The app where the events belongs to.
     * @param request The publish request.
     * @return Events created.
     */
    postEvents(appId: string, request: PublishManyDto): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/events";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostEvents(_response);
        });
    }

    protected processPostEvents(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Publish an event for the current user.
     * @param request The publish request.
     * @return Event created.
     */
    postMyEvents(request: PublishDto): Promise<void> {
        let url_ = this.baseUrl + "/api/me/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostMyEvents(_response);
        });
    }

    protected processPostMyEvents(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ConfigsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Get all supported timezones.
     * @return Timezones returned.
     */
    getTimezones(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/timezones";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimezones(_response);
        });
    }

    protected processGetTimezones(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * Get all supported languages.
     * @return Languages returned.
     */
    getLanguages(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/languages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLanguages(_response);
        });
    }

    protected processGetLanguages(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }
}

export class EmailTemplatesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Get the HTML preview for a channel template.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @return Channel template preview returned.
     */
    getPreview(appId: string, id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/apps/{appId}/email-templates/{id}/preview";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPreview(_response);
        });
    }

    protected processGetPreview(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Render a preview for a email template.
     * @param appId The id of the app where the templates belong to.
     * @param request The template to render.
     * @return Template rendered.
     */
    postPreview(appId: string, request: EmailPreviewRequestDto): Promise<EmailPreviewDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/email-templates/render";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostPreview(_response);
        });
    }

    protected processPostPreview(response: Response): Promise<EmailPreviewDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailPreviewDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmailPreviewDto>(<any>null);
    }

    /**
     * Get the channel templates.
     * @param appId The id of the app where the templates belong to.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return Channel templates returned.
     */
    getTemplates(appId: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfChannelTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/email-templates?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplates(_response);
        });
    }

    protected processGetTemplates(response: Response): Promise<ListResponseDtoOfChannelTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfChannelTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfChannelTemplateDto>(<any>null);
    }

    /**
     * Create a channel template.
     * @param appId The id of the app where the templates belong to.
     * @param request The request object.
     * @return Channel template created.
     */
    postTemplate(appId: string, request: CreateChannelTemplateDto): Promise<ChannelTemplateDetailsDtoOfEmailTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/email-templates";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostTemplate(_response);
        });
    }

    protected processPostTemplate(response: Response): Promise<ChannelTemplateDetailsDtoOfEmailTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ChannelTemplateDetailsDtoOfEmailTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChannelTemplateDetailsDtoOfEmailTemplateDto>(<any>null);
    }

    /**
     * Get the channel template by id.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @return Channel templates returned.
     */
    getTemplate(appId: string, id: string): Promise<ChannelTemplateDetailsDtoOfEmailTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/email-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplate(_response);
        });
    }

    protected processGetTemplate(response: Response): Promise<ChannelTemplateDetailsDtoOfEmailTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ChannelTemplateDetailsDtoOfEmailTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChannelTemplateDetailsDtoOfEmailTemplateDto>(<any>null);
    }

    /**
     * Create an app template language.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param request The request object.
     * @return Channel template created.
     */
    postTemplateLanguage(appId: string, id: string, request: CreateChannelTemplateLanguageDto): Promise<EmailTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/email-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostTemplateLanguage(_response);
        });
    }

    protected processPostTemplateLanguage(response: Response): Promise<EmailTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmailTemplateDto>(<any>null);
    }

    /**
     * Update an app template.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param request The request object.
     * @return Channel template updated.
     */
    putTemplate(appId: string, id: string, request: UpdateChannelTemplateDtoOfEmailTemplateDto): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/email-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutTemplate(_response);
        });
    }

    protected processPutTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a channel template.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @return Channel template deleted.
     */
    deleteTemplate(appId: string, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/email-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTemplate(_response);
        });
    }

    protected processDeleteTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update a channel template language.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param language The language.
     * @param request The request object.
     * @return Channel template updated.
     */
    putTemplateLanguage(appId: string, id: string, language: string, request: EmailTemplateDto): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/email-templates/{id}/{language}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutTemplateLanguage(_response);
        });
    }

    protected processPutTemplateLanguage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a language channel template.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param language The language.
     * @return Channel template updated.
     */
    deleteTemplateLanguage(appId: string, id: string, language: string): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/email-templates/{id}/{language}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTemplateLanguage(_response);
        });
    }

    protected processDeleteTemplateLanguage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class MessagingTemplatesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Get the channel templates.
     * @param appId The id of the app where the templates belong to.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return Channel templates returned.
     */
    getTemplates(appId: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfChannelTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/messaging-templates?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplates(_response);
        });
    }

    protected processGetTemplates(response: Response): Promise<ListResponseDtoOfChannelTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfChannelTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfChannelTemplateDto>(<any>null);
    }

    /**
     * Create a channel template.
     * @param appId The id of the app where the templates belong to.
     * @param request The request object.
     * @return Channel template created.
     */
    postTemplate(appId: string, request: CreateChannelTemplateDto): Promise<ChannelTemplateDetailsDtoOfMessagingTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/messaging-templates";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostTemplate(_response);
        });
    }

    protected processPostTemplate(response: Response): Promise<ChannelTemplateDetailsDtoOfMessagingTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ChannelTemplateDetailsDtoOfMessagingTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChannelTemplateDetailsDtoOfMessagingTemplateDto>(<any>null);
    }

    /**
     * Get the channel template by id.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @return Channel templates returned.
     */
    getTemplate(appId: string, id: string): Promise<ChannelTemplateDetailsDtoOfMessagingTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/messaging-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplate(_response);
        });
    }

    protected processGetTemplate(response: Response): Promise<ChannelTemplateDetailsDtoOfMessagingTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ChannelTemplateDetailsDtoOfMessagingTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChannelTemplateDetailsDtoOfMessagingTemplateDto>(<any>null);
    }

    /**
     * Create an app template language.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param request The request object.
     * @return Channel template created.
     */
    postTemplateLanguage(appId: string, id: string, request: CreateChannelTemplateLanguageDto): Promise<MessagingTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/messaging-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostTemplateLanguage(_response);
        });
    }

    protected processPostTemplateLanguage(response: Response): Promise<MessagingTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MessagingTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessagingTemplateDto>(<any>null);
    }

    /**
     * Update an app template.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param request The request object.
     * @return Channel template updated.
     */
    putTemplate(appId: string, id: string, request: UpdateChannelTemplateDtoOfMessagingTemplateDto): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/messaging-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutTemplate(_response);
        });
    }

    protected processPutTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a channel template.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @return Channel template deleted.
     */
    deleteTemplate(appId: string, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/messaging-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTemplate(_response);
        });
    }

    protected processDeleteTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update a channel template language.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param language The language.
     * @param request The request object.
     * @return Channel template updated.
     */
    putTemplateLanguage(appId: string, id: string, language: string, request: MessagingTemplateDto): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/messaging-templates/{id}/{language}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutTemplateLanguage(_response);
        });
    }

    protected processPutTemplateLanguage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a language channel template.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param language The language.
     * @return Channel template updated.
     */
    deleteTemplateLanguage(appId: string, id: string, language: string): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/messaging-templates/{id}/{language}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTemplateLanguage(_response);
        });
    }

    protected processDeleteTemplateLanguage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SmsTemplatesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Get the channel templates.
     * @param appId The id of the app where the templates belong to.
     * @param query (optional) The optional query to search for items.
     * @param take (optional) The number of items to return.
     * @param skip (optional) The number of items to skip.
     * @return Channel templates returned.
     */
    getTemplates(appId: string, query?: string | null | undefined, take?: number | undefined, skip?: number | undefined): Promise<ListResponseDtoOfChannelTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/sms-templates?";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplates(_response);
        });
    }

    protected processGetTemplates(response: Response): Promise<ListResponseDtoOfChannelTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ListResponseDtoOfChannelTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResponseDtoOfChannelTemplateDto>(<any>null);
    }

    /**
     * Create a channel template.
     * @param appId The id of the app where the templates belong to.
     * @param request The request object.
     * @return Channel template created.
     */
    postTemplate(appId: string, request: CreateChannelTemplateDto): Promise<ChannelTemplateDetailsDtoOfSmsTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/sms-templates";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostTemplate(_response);
        });
    }

    protected processPostTemplate(response: Response): Promise<ChannelTemplateDetailsDtoOfSmsTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ChannelTemplateDetailsDtoOfSmsTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChannelTemplateDetailsDtoOfSmsTemplateDto>(<any>null);
    }

    /**
     * Get the channel template by id.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @return Channel templates returned.
     */
    getTemplate(appId: string, id: string): Promise<ChannelTemplateDetailsDtoOfSmsTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/sms-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplate(_response);
        });
    }

    protected processGetTemplate(response: Response): Promise<ChannelTemplateDetailsDtoOfSmsTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ChannelTemplateDetailsDtoOfSmsTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChannelTemplateDetailsDtoOfSmsTemplateDto>(<any>null);
    }

    /**
     * Create an app template language.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param request The request object.
     * @return Channel template created.
     */
    postTemplateLanguage(appId: string, id: string, request: CreateChannelTemplateLanguageDto): Promise<SmsTemplateDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/sms-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostTemplateLanguage(_response);
        });
    }

    protected processPostTemplateLanguage(response: Response): Promise<SmsTemplateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SmsTemplateDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SmsTemplateDto>(<any>null);
    }

    /**
     * Update an app template.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param request The request object.
     * @return Channel template updated.
     */
    putTemplate(appId: string, id: string, request: UpdateChannelTemplateDtoOfSmsTemplateDto): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/sms-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutTemplate(_response);
        });
    }

    protected processPutTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a channel template.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @return Channel template deleted.
     */
    deleteTemplate(appId: string, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/sms-templates/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTemplate(_response);
        });
    }

    protected processDeleteTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update a channel template language.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param language The language.
     * @param request The request object.
     * @return Channel template updated.
     */
    putTemplateLanguage(appId: string, id: string, language: string, request: SmsTemplateDto): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/sms-templates/{id}/{language}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutTemplateLanguage(_response);
        });
    }

    protected processPutTemplateLanguage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a language channel template.
     * @param appId The id of the app where the templates belong to.
     * @param id The template ID.
     * @param language The language.
     * @return Channel template updated.
     */
    deleteTemplateLanguage(appId: string, id: string, language: string): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/sms-templates/{id}/{language}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTemplateLanguage(_response);
        });
    }

    protected processDeleteTemplateLanguage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Channel template or app not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AppsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    /**
     * Get the user apps.
     * @return Apps returned.
     */
    getApps(): Promise<AppDto[]> {
        let url_ = this.baseUrl + "/api/apps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApps(_response);
        });
    }

    protected processGetApps(response: Response): Promise<AppDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AppDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppDto[]>(<any>null);
    }

    /**
     * Create an app.
     * @param request The request object.
     * @return App created.
     */
    postApp(request: UpsertAppDto): Promise<AppDto> {
        let url_ = this.baseUrl + "/api/apps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostApp(_response);
        });
    }

    protected processPostApp(response: Response): Promise<AppDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AppDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppDto>(<any>null);
    }

    /**
     * Get app by id.
     * @param appId The id of the app.
     * @return Apps returned.
     */
    getApp(appId: string): Promise<AppDetailsDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApp(_response);
        });
    }

    protected processGetApp(response: Response): Promise<AppDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AppDetailsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppDetailsDto>(<any>null);
    }

    /**
     * Update an app.
     * @param appId The app id to update.
     * @param request The request object.
     * @return App updated.
     */
    putApp(appId: string, request: UpsertAppDto): Promise<AppDetailsDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutApp(_response);
        });
    }

    protected processPutApp(response: Response): Promise<AppDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AppDetailsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppDetailsDto>(<any>null);
    }

    /**
     * Add an app contributor.
     * @param appId The id of the app.
     * @param request The request object.
     * @return Apps returned.
     */
    postContributor(appId: string, request: AddContributorDto): Promise<AppDetailsDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/contributors";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostContributor(_response);
        });
    }

    protected processPostContributor(response: Response): Promise<AppDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AppDetailsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppDetailsDto>(<any>null);
    }

    /**
     * Delete an app contributor.
     * @param appId The id of the app.
     * @param contributorId The contributor to remove.
     * @return Apps returned.
     */
    deleteContributor(appId: string, contributorId: string): Promise<AppDetailsDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/contributors/{contributorId}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (contributorId === undefined || contributorId === null)
            throw new Error("The parameter 'contributorId' must be defined.");
        url_ = url_.replace("{contributorId}", encodeURIComponent("" + contributorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContributor(_response);
        });
    }

    protected processDeleteContributor(response: Response): Promise<AppDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AppDetailsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppDetailsDto>(<any>null);
    }

    /**
     * Get the app integrations.
     * @param appId The id of the app where the integrations belong to.
     * @return App email templates returned.
     */
    getIntegrations(appId: string): Promise<ConfiguredIntegrationsDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/integrations";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIntegrations(_response);
        });
    }

    protected processGetIntegrations(response: Response): Promise<ConfiguredIntegrationsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ConfiguredIntegrationsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConfiguredIntegrationsDto>(<any>null);
    }

    /**
     * Create an app integrations.
     * @param appId The id of the app where the integration belong to.
     * @param request The request object.
     * @return App integration created.
     */
    postIntegration(appId: string, request: CreateIntegrationDto): Promise<IntegrationCreatedDto> {
        let url_ = this.baseUrl + "/api/apps/{appId}/integration";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostIntegration(_response);
        });
    }

    protected processPostIntegration(response: Response): Promise<IntegrationCreatedDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IntegrationCreatedDto>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IntegrationCreatedDto>(<any>null);
    }

    /**
     * Update an app integration.
     * @param appId The id of the app where the integration belong to.
     * @param id The id of the integration.
     * @param request The request object.
     * @return App integration updated.
     */
    putIntegration(appId: string, id: string, request: UpdateIntegrationDto): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/integrations/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutIntegration(_response);
        });
    }

    protected processPutIntegration(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete an app integration.
     * @param appId The id of the app where the email templates belong to.
     * @param id The id of the integration.
     * @return App integration deleted.
     */
    deleteIntegration(appId: string, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/apps/{appId}/integrations/{id}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteIntegration(_response);
        });
    }

    protected processDeleteIntegration(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("App not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AuthorizationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    exchange(): Promise<void> {
        let url_ = this.baseUrl + "/connect/token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExchange(_response);
        });
    }

    protected processExchange(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    authorize(): Promise<void> {
        let url_ = this.baseUrl + "/connect/authorize";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthorize(_response);
        });
    }

    protected processAuthorize(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    logout(): Promise<void> {
        let url_ = this.baseUrl + "/connect/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserInfoClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5002";
    }

    userinfoGET(): Promise<void> {
        let url_ = this.baseUrl + "/connect/userinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserinfoGET(_response);
        });
    }

    protected processUserinfoGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    userinfoPOST(): Promise<void> {
        let url_ = this.baseUrl + "/connect/userinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserinfoPOST(_response);
        });
    }

    protected processUserinfoPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Operation failed", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("Validation error", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface ProfileDto {
    /** The full name of the user. */
    fullName: string;
    /** The email of the user. */
    emailAddress: string;
    /** The phone number. */
    phoneNumber?: string | undefined;
    /** The preferred language of the user. */
    preferredLanguage?: string | undefined;
    /** The timezone of the user. */
    preferredTimezone?: string | undefined;
    /** The supported languages. */
    supportedLanguages: string[];
    /** The supported timezones. */
    supportedTimezones: string[];
    /** Notification settings per channel. */
    settings: { [key: string]: NotificationSettingDto; };
}

export interface NotificationSettingDto {
    /** True or false to send the notification for the channel. */
    send: NotificationSend;
    /** The delay in seconds. */
    delayInSeconds?: number | undefined;
    /** The template if the channel supports it. */
    template?: string | undefined;
}

export type NotificationSend = "Inherit" | "Send" | "NotSending" | "NotAllowed";

export interface UpdateProfileDto {
    /** The full name of the user. */
    fullName?: string | undefined;
    /** The email of the user. */
    emailAddress?: string | undefined;
    /** The phone number. */
    phoneNumber?: string | undefined;
    /** The preferred language of the user. */
    preferredLanguage?: string | undefined;
    /** The timezone of the user. */
    preferredTimezone?: string | undefined;
    /** Notification settings per channel. */
    settings?: { [key: string]: NotificationSettingDto; } | undefined;
}

export interface SubscriptionDto {
    /** The topic to add. */
    topicPrefix: string;
    /** Notification settings per channel. */
    topicSettings?: { [key: string]: NotificationSettingDto; } | undefined;
}

export interface ListResponseDtoOfUserDto {
    /** The items. */
    items: UserDto[];
    /** The total number of items. */
    total: number;
}

export interface UserDto {
    /** The id of the user. */
    id: string;
    /** The unique api key for the user. */
    apiKey: string;
    /** The full name of the user. */
    fullName?: string | undefined;
    /** The email of the user. */
    emailAddress?: string | undefined;
    /** The phone number. */
    phoneNumber?: string | undefined;
    /** The threema id. */
    threemaId?: string | undefined;
    /** The preferred language of the user. */
    preferredLanguage?: string | undefined;
    /** The timezone of the user. */
    preferredTimezone?: string | undefined;
    /** The number of web hook tokens. */
    numberOfWebPushTokens: number;
    /** The number of web hook tokens. */
    numberOfMobilePushTokens: number;
    /** True when only whitelisted topic are allowed. */
    requiresWhitelistedTopics: boolean;
    /** Notification settings per channel. */
    settings: { [key: string]: NotificationSettingDto; };
    /** The statistics counters. */
    counters: { [key: string]: number; };
    /** The mobile push tokens. */
    mobilePushTokens: MobilePushTokenDto[];
}

export interface MobilePushTokenDto {
    /** The token. */
    token: string;
    /** The device type. */
    deviceType: MobileDeviceType;
    /** The last time the device was woken up. */
    lastWakeup?: Date | undefined;
}

export type MobileDeviceType = "Unknown" | "Android" | "iOS";

export interface ListResponseDtoOfSubscriptionDto {
    /** The items. */
    items: SubscriptionDto[];
    /** The total number of items. */
    total: number;
}

export interface UpsertUsersDto {
    /** The users to update. */
    requests: UpsertUserDto[];
}

export interface UpsertUserDto {
    /** The id of the user. */
    id?: string | undefined;
    /** The full name of the user. */
    fullName?: string | undefined;
    /** The email of the user. */
    emailAddress?: string | undefined;
    /** The phone number. */
    phoneNumber?: string | undefined;
    /** The threema id. */
    threemaId?: string | undefined;
    /** The preferred language of the user. */
    preferredLanguage?: string | undefined;
    /** The timezone of the user. */
    preferredTimezone?: string | undefined;
    /** True when only whitelisted topic are allowed. */
    requiresWhitelistedTopics?: boolean | undefined;
    /** Notification settings per channel. */
    settings?: { [key: string]: NotificationSettingDto; } | undefined;
}

export interface AddAllowedTopicDto {
    /** The topic to add. */
    prefix: string;
}

export interface ListResponseDtoOfTopicDto {
    /** The items. */
    items: TopicDto[];
    /** The total number of items. */
    total: number;
}

export interface TopicDto {
    /** The topic path. */
    path: string;
    /** THe last update to the topic. */
    lastUpdate: Date;
    /** The statistics counters. */
    counters: { [key: string]: number; };
}

export interface ListResponseDtoOfTemplateDto {
    /** The items. */
    items: TemplateDto[];
    /** The total number of items. */
    total: number;
}

export interface TemplateDto {
    /** The code of the template. */
    code: string;
    /** The formatting. */
    formatting: NotificationFormattingDto;
    /** Notification settings per channel. */
    settings: { [key: string]: NotificationSettingDto; };
}

export interface NotificationFormattingDto {
    /** The required subject with one entry per language. */
    subject: LocalizedText;
    /** The optional body with one entry per language. */
    body?: LocalizedText | undefined;
    /** The optional confirm text with one entry per language. */
    confirmText?: LocalizedText | undefined;
    /** The optional small image with one entry per language. */
    imageSmall?: LocalizedText | undefined;
    /** The optional large image with one entry per language. */
    imageLarge?: LocalizedText | undefined;
    /** The optional link url with one entry per language. */
    linkUrl?: LocalizedText | undefined;
    /** The optional link name with one entry per language. */
    linkText?: LocalizedText | undefined;
    /** The confirmation mode. */
    confirmMode: ConfirmMode;
}

export interface LocalizedText {

    [key: string]: string | any; 
}

export type ConfirmMode = "Seen" | "Explicit" | "None";

export interface UpsertTemplatesDto {
    /** The templates to update. */
    requests: UpsertTemplateDto[];
}

export interface UpsertTemplateDto {
    /** The code of the template. */
    code: string;
    /** The formatting. */
    formatting: NotificationFormattingDto;
    /** Notification settings per channel. */
    settings?: { [key: string]: NotificationSettingDto; } | undefined;
}

export interface ListResponseDtoOfUserNotificationDetailsDto {
    /** The items. */
    items: UserNotificationDetailsDto[];
    /** The total number of items. */
    total: number;
}

export interface UserNotificationDto {
    /** The id of the notification. */
    id: string;
    /** The subject of the notification in the language of the user. */
    subject: string;
    /** True when the notification is silent. */
    silent: boolean;
    /** True when the notification has been confirmed. */
    isConfirmed: boolean;
    /** True when the notification has been seen. */
    isSeen: boolean;
    /** The timestamp when the notification has been created. */
    created: Date;
    /** The timestamp when the notification has been updated. */
    updated: Date;
    /** The optional body text. */
    body?: string | undefined;
    /** The optional link to the small image. */
    imageSmall?: string | undefined;
    /** The optional link to the large image. */
    imageLarge?: string | undefined;
    /** The tracking url that needs to be invoked to mark the notifiation as seen. */
    trackingUrl?: string | undefined;
    /** An optional link. */
    linkUrl?: string | undefined;
    /** The link text. */
    linkText?: string | undefined;
    /** The text for the confirm button. */
    confirmText?: string | undefined;
    /** The tracking url that needs to be invoked to mark the notifiation as confirmed. */
    confirmUrl?: string | undefined;
    /** Optional data, usually a json object. */
    data?: string | undefined;
}

export interface UserNotificationDetailsDto extends UserNotificationDto {
    /** The channel details. */
    channels: { [key: string]: UserNotificationChannelDto; };
    /** The information when the notifcation was marked as confirmed. */
    confirmed?: HandledInfoDto | undefined;
    /** The information when the notifcation was marked as seen. */
    seen?: HandledInfoDto | undefined;
}

export interface UserNotificationChannelDto {
    /** The notification settings. */
    setting: NotificationSettingDto;
    /** The status per token or configuration. */
    status: { [key: string]: ChannelSendInfoDto; };
}

export interface ChannelSendInfoDto {
    /** The send status. */
    status?: ProcessStatus;
    /** The last update. */
    lastUpdate?: Date;
    /** The details. */
    detail?: string | undefined;
}

export type ProcessStatus = "None" | "Attempt" | "Handled" | "Failed" | "Skipped";

export interface HandledInfoDto {
    /** The timestamp. */
    timestamp?: Date;
    /** The channel over which the notification was marked as seen or confirmed. */
    channel?: string | undefined;
}

export interface ListResponseDtoOfUserNotificationDto {
    /** The items. */
    items: UserNotificationDto[];
    /** The total number of items. */
    total: number;
}

export interface TrackNotificationDto {
    /** The id of the noitifications to mark as confirmed. */
    confirmed?: string | undefined;
    /** The id of the noitifications to mark as seen. */
    seen?: string[] | undefined;
    /** The channel name. */
    channel?: string | undefined;
    /** The device identifier. */
    deviceIdentifier?: string | undefined;
}

export interface ListResponseDtoOfMobilePushTokenDto {
    /** The items. */
    items: MobilePushTokenDto2[];
    /** The total number of items. */
    total: number;
}

export interface MobilePushTokenDto2 {
    /** The device token. */
    token: string;
    /** The device type. */
    deviceType?: MobileDeviceType;
}

export interface RegisterMobileTokenDto {
    /** The device token. */
    token: string;
    /** The device type. */
    deviceType?: MobileDeviceType;
}

export interface ListResponseDtoOfMediaDto {
    /** The items. */
    items: MediaDto[];
    /** The total number of items. */
    total: number;
}

export interface MediaDto {
    /** The mime type. */
    mimeType: string;
    /** The file name. */
    fileName: string;
    /** Generated information about the file. */
    fileInfo: string;
    /** The size of the media file. */
    fileSize: number;
    /** The url to the media item. */
    url: string;
    /** The type of the media. */
    type: MediaType;
    /** Metadata about the media. */
    metadata: MediaMetadata;
}

export type MediaType = "Unknown" | "Image" | "Audio" | "Video";

export interface MediaMetadata {

    [key: string]: string | any; 
}

export type ResizeMode = "Crop" | "CropUpsize" | "Pad" | "BoxPad" | "Max" | "Min" | "Stretch";

export interface ListResponseDtoOfLogEntryDto {
    /** The items. */
    items: LogEntryDto[];
    /** The total number of items. */
    total: number;
}

export interface LogEntryDto {
    /** The log message. */
    message: string;
    /** The first time this message has been seen. */
    firstSeen: Date;
    /** The last time this message has been seen. */
    lastSeen: Date;
    /** The number of items the message has been seen. */
    count: number;
}

export interface ListResponseDtoOfEventDto {
    /** The items. */
    items: EventDto[];
    /** The total number of items. */
    total: number;
}

export interface EventDto {
    /** The id of the event. */
    id: string;
    /** The topic path. */
    topic: string;
    /** A custom id to identity the creator. */
    creatorId?: string | undefined;
    /** The display name. */
    displayName: string;
    /** Additional user defined data. */
    data?: string | undefined;
    /** The optional name of the Email template. */
    emailTemplate?: string | undefined;
    /** The optional name of the SMS template. */
    smsTemplate?: string | undefined;
    /** The time when the event has been created. */
    created: Date;
    /** The final formatting infos. */
    formatting: NotificationFormattingDto;
    /** Notification settings per channel. */
    settings: { [key: string]: NotificationSettingDto; };
    /** User defined properties. */
    properties: { [key: string]: string; };
    /** The scheduling options. */
    scheduling?: SchedulingDto | undefined;
    /** The statistics counters. */
    counters: { [key: string]: number; };
    /** True when silent. */
    silent: boolean;
    /** The time to live in seconds. */
    timeToLiveInSeconds?: number | undefined;
}

export interface SchedulingDto {
    /** The scheduling type. */
    type?: SchedulingType;
    /** To schedule the event at the next day of the week. */
    nextWeekDay?: IsoDayOfWeek | undefined;
    /** The scheduling date. */
    date?: Date | undefined;
    /** The scheduling time. */
    time?: string;
}

export type SchedulingType = "UTC" | "UserTime";

/** Equates the days of the week with their numerical value according to ISO-8601. This corresponds with System.DayOfWeek except for Sunday, which is 7 in the ISO numbering and 0 in System.DayOfWeek. */
export type IsoDayOfWeek = "None" | "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday";

export interface PublishManyDto {
    /** The publish requests. */
    requests: PublishDto[];
}

export interface PublishDto {
    /** The topic path. */
    topic: string;
    /** A custom id to identity the creator. */
    creatorId?: string | undefined;
    /** The template code. */
    templateCode?: string | undefined;
    /** Additional user defined data. */
    data?: string | undefined;
    /** A custom timestamp. */
    timestamp?: Date;
    /** Preformatting when no template is used. */
    preformatted?: NotificationFormattingDto | undefined;
    /** The notification settings. */
    settings?: { [key: string]: NotificationSettingDto; } | undefined;
    /** User defined properties. */
    properties?: EventProperties | undefined;
    /** The scheduling options. */
    scheduling?: SchedulingDto | undefined;
    /** True when silent. */
    silent?: boolean;
    /** True when using test integrations. */
    test?: boolean;
    /** The time to live in seconds. */
    timeToLiveInSeconds?: number | undefined;
}

export interface EventProperties {

    [key: string]: string | any; 
}

export interface EmailPreviewDto {
    /** The rendered preview. */
    result?: string | undefined;
    /** The errors when rendering a preview. */
    errors?: EmailFormattingError[] | undefined;
}

export interface EmailFormattingError {
    message?: string;
    line?: number;
}

export interface EmailPreviewRequestDto {
    /** The preview to render. */
    template: string;
    /** The template type. */
    type?: EmailPreviewType;
}

export type EmailPreviewType = "Html" | "Text";

export interface ListResponseDtoOfChannelTemplateDto {
    /** The items. */
    items: ChannelTemplateDto[];
    /** The total number of items. */
    total: number;
}

export interface ChannelTemplateDto {
    /** The id of the template. */
    id: string;
    /** The optional name of the template. */
    name?: string | undefined;
    /** True, when the template is the primary template. */
    primary: boolean;
    /** The last time the template has been updated. */
    lastUpdate: Date;
}

export interface ChannelTemplateDetailsDtoOfEmailTemplateDto {
    /** The id of the template. */
    id: string;
    /** The optional name of the template. */
    name?: string | undefined;
    /** True, when the template is the primary template. */
    primary: boolean;
    /** The last time the template has been updated. */
    lastUpdate: Date;
    /** The language specific templates. */
    languages: { [key: string]: EmailTemplateDto; };
}

export interface EmailTemplateDto {
    /** The subject text. */
    subject: string;
    /** The body html template. */
    bodyHtml: string;
    /** The body text template. */
    bodyText?: string | undefined;
}

export interface CreateChannelTemplateDto {
}

export interface CreateChannelTemplateLanguageDto {
    /** The new language. */
    language: string;
}

export interface UpdateChannelTemplateDtoOfEmailTemplateDto {
    /** The name of the template. */
    name?: string | undefined;
    /** True, when the template is the primary template. */
    primary?: boolean | undefined;
    /** The language specific templates. */
    languages?: { [key: string]: EmailTemplateDto; } | undefined;
}

export interface ChannelTemplateDetailsDtoOfMessagingTemplateDto {
    /** The id of the template. */
    id: string;
    /** The optional name of the template. */
    name?: string | undefined;
    /** True, when the template is the primary template. */
    primary: boolean;
    /** The last time the template has been updated. */
    lastUpdate: Date;
    /** The language specific templates. */
    languages: { [key: string]: MessagingTemplateDto; };
}

export interface MessagingTemplateDto {
    /** The template text. */
    text: string;
}

export interface UpdateChannelTemplateDtoOfMessagingTemplateDto {
    /** The name of the template. */
    name?: string | undefined;
    /** True, when the template is the primary template. */
    primary?: boolean | undefined;
    /** The language specific templates. */
    languages?: { [key: string]: MessagingTemplateDto; } | undefined;
}

export interface ChannelTemplateDetailsDtoOfSmsTemplateDto {
    /** The id of the template. */
    id: string;
    /** The optional name of the template. */
    name?: string | undefined;
    /** True, when the template is the primary template. */
    primary: boolean;
    /** The last time the template has been updated. */
    lastUpdate: Date;
    /** The language specific templates. */
    languages: { [key: string]: SmsTemplateDto; };
}

export interface SmsTemplateDto {
    /** The template text. */
    text: string;
}

export interface UpdateChannelTemplateDtoOfSmsTemplateDto {
    /** The name of the template. */
    name?: string | undefined;
    /** True, when the template is the primary template. */
    primary?: boolean | undefined;
    /** The language specific templates. */
    languages?: { [key: string]: SmsTemplateDto; } | undefined;
}

export interface AppDto {
    /** The id of the app. */
    id: string;
    /** The app name. */
    name: string;
    /** The current role. */
    role: string;
    /** The supported languages. */
    languages: string[];
    /** The api keys. */
    apiKeys: { [key: string]: string; };
    /** The statistics counters. */
    counters: { [key: string]: number; };
}

export interface AppDetailsDto {
    /** The id of the app. */
    id: string;
    /** The app name. */
    name: string;
    /** The current role. */
    role: string;
    /** The supported languages. */
    languages: string[];
    /** The confirm URL. */
    confirmUrl?: string | undefined;
    /** The api keys. */
    apiKeys: { [key: string]: string; };
    /** The contributors. */
    contributors: AppContributorDto[];
    /** The statistics counters. */
    counters: { [key: string]: number; };
}

export interface AppContributorDto {
    /** The id of the user. */
    userId: string;
    /** The name of the user. */
    userName: string;
    /** The role. */
    role: string;
}

export interface UpsertAppDto {
    /** The app name. */
    name?: string | undefined;
    /** The supported languages. */
    languages?: string[] | undefined;
    /** The sender email address. */
    emailAddress?: string | undefined;
    /** The sender email name. */
    emailName?: string | undefined;
    /** The firebase project ID. */
    firebaseProject?: string | undefined;
    /** The firebase credentials. */
    firebaseCredential?: string | undefined;
    /** The webhook URL. */
    webhookUrl?: string | undefined;
    /** The confirm URL. */
    confirmUrl?: string | undefined;
    /** True, when emails are allowed. */
    allowEmail?: boolean | undefined;
    /** True, when SMS are allowed. */
    allowSms?: boolean | undefined;
}

export interface AddContributorDto {
    /** The email of the new contributor. */
    email: string;
    /** The role. */
    role: string;
}

export interface ConfiguredIntegrationsDto {
    /** The configured integrations. */
    configured: { [key: string]: ConfiguredIntegrationDto; };
    /** The supported integrations. */
    supported: { [key: string]: IntegrationDefinitionDto; };
}

export interface ConfiguredIntegrationDto {
    /** The integration type. */
    type: string;
    /** The configured properties. */
    properties: IntegrationProperties;
    /** True when enabled. */
    enabled?: boolean;
    /** True or false when only used for test or production mode. */
    test?: boolean | undefined;
    /** The priority in which order the integrations must run. */
    priority?: number;
    /** The status of the integration. */
    status: IntegrationStatus;
}

export interface IntegrationProperties {

    [key: string]: string | any; 
}

export type IntegrationStatus = "Verified" | "VerificationFailed" | "Pending";

export interface IntegrationDefinitionDto {
    /** The title of the integration. */
    title: string;
    /** The logo URL for the integration. */
    logoUrl: string;
    /** The optional description of the integration. */
    description?: string | undefined;
    /** The properties to configure. */
    properties: IntegrationPropertyDto[];
    /** The features of the integration. */
    capabilities: string[];
}

export interface IntegrationPropertyDto {
    /** The field name for the property. */
    name: string;
    /** The editor type. */
    type: IntegrationPropertyType;
    /** The optional description. */
    editorDescription?: string | undefined;
    /** The optional label. */
    editorLabel?: string | undefined;
    /** True to show this property in the summary. */
    summary?: boolean;
    /** The allowed values. */
    allowedValues?: string[] | undefined;
    /** True when required. */
    isRequired?: boolean;
    /** The min value (for numbers). */
    minValue?: number;
    /** The max value (for numbers). */
    maxValue?: number;
    /** The min length (for strings). */
    minLength?: number;
    /** The min length (for strings). */
    maxLength?: number;
    /** The default value. */
    defaultValue?: any | undefined;
}

export type IntegrationPropertyType = "Text" | "Number" | "MultilineText" | "Password" | "Boolean";

export interface IntegrationCreatedDto {
    /** The id of the integration. */
    id: string;
    /** The integration. */
    integration: ConfiguredIntegrationDto;
}

export interface CreateIntegrationDto {
    /** The integration type. */
    type: string;
    /** The configured properties. */
    properties: IntegrationProperties;
    /** True when enabled. */
    enabled?: boolean;
    /** True when used for test events. */
    test?: boolean | undefined;
    /** The priority in which order the integrations must run. */
    priority?: number;
}

export interface UpdateIntegrationDto {
    /** The configured properties. */
    properties: IntegrationProperties;
    /** True when enabled. */
    enabled?: boolean;
    /** True when used for test events. */
    test?: boolean | undefined;
    /** The priority in which order the integrations must run. */
    priority?: number;
}

export interface ErrorDto {
    /** The error message. */
    message?: string | undefined;
    /** The optional trace id. */
    traceId?: string | undefined;
    /** The error type, usually a link. */
    type?: string | undefined;
    /** Detailed error messages. */
    details?: string[] | undefined;
    /** Status code of the http response. */
    statusCode?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}